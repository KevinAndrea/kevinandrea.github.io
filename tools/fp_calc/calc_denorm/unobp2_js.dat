
// The minimum digit accuracy of a calculated float
const MINACC = 15;

// Signifies "no bias specified"
const NOVAL = "NOVAL";

// The program re-reads the textboxes after every input, which can cause issues with
//    mismatches. For example, if the exponent text was changed to five but there are
//    only four checkboxes, it will still check for that fifth checkbox. This fixes that
//    by having a history to check with and re-forming the UI if anything changes. Could
//    these values instead be used for calculations? Yes, but that would mean stale
//    information would be left on the screen.
var hwid = 0, hbias = 0, hexpn = 0;

/*
 * getMax - Gets the max possible value of a float
 * Parameters: The width of the mantissa in bits and the max exponent value
 * Output: A BigInt representing the largest possible value of a float (following IEEE
 *    rules) with the given parameters
 */
function getMax(mtswid, expn) {
	// This "works", but will readily try to calculate a thousand-decimal number to the
	//    ones place, which isn't really necessary and can easily freeze the system
	/*
	try {
		var max = (2n ** expn) * 2n;
		max -= max / (2n ** (BigInt(mtswid) + 1n));
		return max;
	} catch(error) {
		return -1;
	}
	*/
	
	// TODO: Setting an exponent width of 32 results in an exponent of 2147483647, maybe find an easier way of calculating
	var mtsval;
	// Interesting corner case: If the exponent's width is 1 (why?), any values will
	//    always be either subnormal or NaN/Inf, so the max value is forced to be
	//    subnormal
	if(expn == 0) {
		mtsval = (2n ** BigInt(mtswid)) - 1n;
		expn++;
	} else {
		mtsval = (2n ** BigInt(mtswid + 1)) - 1n;
	}
	// ----- Value Calculation -----
	//console.log(Number(mtsval) / (2 ** mtswid) * (2 ** Number(expn)));
	var mtdiv = 2n ** BigInt(mtswid); // the mantissa divisor
	var dexp = MINACC; // The power of 10 that the mantissa is currently multiplied by, to keep sig figs
	// "dexp" is a negative decimal exponent
	
	// Count off the mantissa divisor's length, to shift the mantissa up and ensure no bits are lost
	// There isn't a log function for BigInts, so...
	var mtlen = BigInt(mtdiv);
	while(mtlen > 0) {
		dexp++;
		mtlen /= 10n;
	}
	
	var fval = mtsval * (10n ** BigInt(dexp)); // The final value
	fval /= mtdiv; // At this point, fval is the pre-exponentiated mantissa, times dexp
	
	for(let i = 0n; i < expn; i += 1n) {
		fval *= 2n;
		while(fval.toString().length > 30) {
			fval /= 10n;
			dexp--;
		}
	}
	return toExpnDiv(fval.toString(), dexp);
}

/*
 * stageClr - Clears a div "stage"
 * Parameters: The number of an HTML div with the ID "stage#"
 * Output: An Element representing the div
 * Behavior: Removes all child Elements from the div
 */
function stageClr(num) {
	var div = document.getElementById("stage" + num);
	while(div.firstChild) {
		div.lastChild.remove();
	}
	return div;
}

/*
 * getWid - Gets the "width" value
 * Output: The inputted width value, or -1 if the input was invalid
 * Behavior: If the input was invalid, the HTML Elements after the width input are
 *    removed and a warning is added
 */
function getWid() {
	var width = document.getElementById("width").value;
	var widval = parseInt(width);
	if(!(width == widval)) {
		var div = stageClr(2);
		var ntxt = document.createElement("p");
		ntxt.innerHTML = "Please enter a valid width";
		div.append(ntxt);
		return -1;
	}
	if(widval <= 2 || widval > 128) {
		var div = stageClr(2);
		var ntxt = document.createElement("p");
		ntxt.innerHTML = "Please enter a width between 3 and 128";
		div.append(ntxt);
		return -1;
	}
	
	return widval;
}

/*
 * getBias - Gets the "bias" value
 * Output: The inputted bias value as a BigInt, "" if the input was invalid, or "NOVAL"
 *    if the input was disabled via the checkbox
 * Behavior: If the input was invalid, the HTML Elements after the bias input are
 *    removed and a warning is added
 */
function getBias() {
	if(!document.getElementById("cexpchk").checked) {
		return NOVAL;
	}
	var bias = document.getElementById("cexptxt").value;
	var biasval = BigInt(bias);
	if(!(bias == biasval) || bias == "") {
		var div = stageClr(3);
		var ntxt = document.createElement("p");
		ntxt.innerHTML = "Please enter a valid exponent bias";
		div.append(ntxt);
		return "";
	}
	// TODO: Figure out reasonable limits
	/*if(biasval <= 2 || biasval > 128) {
		var div = stageClr(3);
		var ntxt = document.createElement("p");
		ntxt.innerHTML = "Please enter a width between 3 and 128";
		div.append(ntxt);
		return -1;
	}*/
	return bias;
}

/*
 * getMantissa - Gets the "mantissa" value
 * Parameters: The inputted "width" value
 * Output: The mantissa width value caluclated with the given width and the inputted
 *    exponent width values, or -1 if the exponent input was invalid
 * Behavior: If the exponent input was invalid, the HTML Elements after the exponent
 *    input are removed and a warning is added
 */
function getMantissa(wid) {
	var expn = document.getElementById("expwid").value;
	var expnval = parseInt(expn);
	if(!(expn == expnval)) {
		var div = stageClr(3);
		var ntxt = document.createElement("p");
		ntxt.innerHTML = "Please enter a valid exponent width";
		div.append(ntxt);
		return -1;
	}
	
	if(expnval < 1) {
		var div = stageClr(3);
		var ntxt = document.createElement("p");
		ntxt.innerHTML = "Please enter a width above 0";
		div.append(ntxt);
		return -1;
	}
	
	var mts = wid - expnval - 1;
	if(mts < 1) {
		var div = stageClr(3);
		var ntxt = document.createElement("p");
		ntxt.innerHTML = "Please leave space for the mantissa";
		div.append(ntxt);
		return -1;
	}
	
	return mts;
}

/*
 * doStats - Displays stats
 * Parameters: The div "stage" to add the stats to, and the width, mantissa width, and
 *    exponent bias of a floating point format
 * Behavior: Displays stats on the given format, including the maximum value possible
 */
function doStats(stage3, wid, mts, bias) {
	var expn = wid - mts - 1;
	
	var ndiv = document.createElement("div");
	ndiv.id = "stats";
	stage3.append(ndiv);
	
	var nhdr = document.createElement("h3");
	nhdr.innerHTML = "Stats";
	ndiv.append(nhdr);
	
	var ntxt = document.createElement("p");
	ntxt.innerHTML = "Total width: " + wid;
	ndiv.append(ntxt);
	
	ntxt = document.createElement("p");
	ntxt.innerHTML = "Exponent width: " + expn;
	ndiv.append(ntxt);
	
	ntxt = document.createElement("p");
	ntxt.innerHTML = "Mantissa width: " + mts;
	ndiv.append(ntxt);
	
	var bval;
	if(bias == NOVAL) {
		bval = ((2n ** BigInt(expn - 1)) - 1n);
	} else {
		bval = BigInt(bias);
	}
	ntxt = document.createElement("p");
	ntxt.innerHTML = "Exponent bias: " + bval;
	ndiv.append(ntxt);
	
	var mmval = ((2n ** BigInt(mts)) - 1n);
	ntxt = document.createElement("p");
	ntxt.innerHTML = "Max raw mantissa value: " + mmval;
	ndiv.append(ntxt);
	
	var mtsdisp = 1 / 2 ** mts;
	ntxt = document.createElement("p");
	ntxt.innerHTML = "Precision, mantissa LSB: " + mtsdisp;
	ndiv.append(ntxt);
	
	var meval = ((2n ** BigInt(expn)) - 2n - bval);
	ntxt = document.createElement("p");
	ntxt.innerHTML = "Max exponent value: " + meval;
	ndiv.append(ntxt);
	
	var maxval = getMax(mts, meval);
	ntxt = document.createElement("p");
	if(maxval == -1) {
		ntxt.innerHTML = "Max value too large to calculate";
	} else {
		maxval = maxval.toString();
		//if(maxval.length > 20) maxval = toExpn(maxval);
		ntxt.innerHTML = "Max representable value: " + maxval;
	}
	ndiv.append(ntxt);
}

/*
 * stage2 - Displays stage 2
 * Behavior: Modifies the HTML layout, adding an input for the exponent width and
 *    optional bias
 */
function stage2() {
	var div = stageClr(2);
	
	var wid = getWid();
	if(wid == -1) return;
	
	var nhdr = document.createElement("h2");
	nhdr.innerHTML = "Division";
	div.append(nhdr);
	
	var ntxt = document.createElement("p");
	ntxt.innerHTML = "A floating point number is divided into three sections: the sign bit, the exponent, and the mantissa, or unexponentiated value. The exponent width controls the range of values, while the mantissa width controls the precision of each value. For general-purpose values the exponent is usually kept small compared to the mantissa, though in AI-focused values the exponent can be over half the width.";
	div.append(ntxt);
	
	var nexpbit = document.createElement("p");
	nexpbit.innerHTML = "The exponent's width in bits: ";
	div.append(nexpbit);
	
	var nexptxt = document.createElement("input");
	nexptxt.id = "expwid";
	nexptxt.type = "number";
  nexptxt.value = 3;
	nexpbit.append(nexptxt);
	
	var ntxt2 = document.createElement("p");
	ntxt2.innerHTML = "The exponent's value is biased in order to allow for negative exponent representations while still keeping value comparisons simple. Normally, the bias is 2^(e-1)-1, with e being the width of the exponent.";// However, some formats use a custom bias.";
	div.append(ntxt2);
	
	var ncexp = document.createElement("p");
	ncexp.innerHTML = "Force the exponent's bias to: ";
	div.append(ncexp);
	
	var nchk = document.createElement("input");
	nchk.id = "cexpchk";
	nchk.type = "checkbox";
	nchk.onclick = function() {
		document.getElementById("cexptxt").disabled = !this.checked;
	};
	ncexp.append(nchk);
	
	var nctxt = document.createElement("input");
	nctxt.id = "cexptxt";
	nctxt.type = "number";
	nctxt.disabled = true;
	ncexp.append(nctxt);
	
	var nexpbtn = document.createElement("button");
	nexpbtn.type = "button";
	nexpbtn.innerHTML = "Go";
	nexpbtn.setAttribute("onclick", "stage3()");
	div.append(nexpbtn);
	
	var ndiv = document.createElement("div");
	ndiv.id = "stage3";
	div.append(ndiv);
}

/*
 * stage3 - Displays stage 3
 * Behavior: Modifies the HTML layout, adding a stats display and checkboxes for
 *    toggling bits of a simulated float
 */
function stage3() {
	var div = stageClr(3);
	
	var wid = getWid();
	if(wid == -1) return;
	
	var mts = getMantissa(wid);
	if(mts == -1) return;
	var expn = wid - mts - 1;
	
	var bias = getBias();
	if(bias == "") return;
	
	doStats(div, wid, mts, bias);
	
	var nhdr = document.createElement("h2");
	nhdr.innerHTML = "Testing";
	div.append(nhdr);
	
	var ntxt = document.createElement("p");
	ntxt.innerHTML = "Below is a simulation of how the floating point should be calculated. Flip the bits to change the value.";
	div.append(ntxt);
	
	var nchk = document.createElement("input");
	nchk.id = "sgnbit";
	nchk.type = "checkbox";
	nchk.className = "sgnstyle";
	nchk.setAttribute("onclick", "stage4()");
	div.append(nchk);
	
	for(let i = 0; i < expn; i++) {
		nchk = document.createElement("input");
		nchk.id = "expbit" + i;
		nchk.type = "checkbox";
		nchk.className = "expstyle";
		nchk.setAttribute("onclick", "stage4()");
		div.append(nchk);
	}
	
	for(let i = 0; i < mts; i++) {
		nchk = document.createElement("input");
		nchk.id = "mtsbit" + i;
		nchk.type = "checkbox";
		nchk.className = "mtsstyle";
		nchk.setAttribute("onclick", "stage4()");
		div.append(nchk);
	}
	
	div.append(document.createElement("br"));
	
	var nbtn = document.createElement("button");
	nbtn.type = "button";
	nbtn.innerHTML = "Increment";
	nbtn.setAttribute("onclick", "addOne()");
	div.append(nbtn);
	
	var nbtn = document.createElement("button");
	nbtn.type = "button";
	nbtn.innerHTML = "Decrement";
	nbtn.setAttribute("onclick", "subOne()");
	div.append(nbtn);
	
	nbtn = document.createElement("button");
	nbtn.type = "button";
	nbtn.innerHTML = "Set exponents";
	nbtn.setAttribute("onclick", "setExp(true)");
	div.append(nbtn);
	
	nbtn = document.createElement("button");
	nbtn.type = "button";
	nbtn.innerHTML = "Clear exponents";
	nbtn.setAttribute("onclick", "setExp(false)");
	div.append(nbtn);
	
	nbtn = document.createElement("button");
	nbtn.type = "button";
	nbtn.innerHTML = "Set mantissa";
	nbtn.setAttribute("onclick", "setMts(true)");
	div.append(nbtn);
	
	nbtn = document.createElement("button");
	nbtn.type = "button";
	nbtn.innerHTML = "Clear mantissa";
	nbtn.setAttribute("onclick", "setMts(false)");
	div.append(nbtn);
	
	var ndiv = document.createElement("div");
	ndiv.id = "stage4";
	div.append(ndiv);
	
	hwid = wid;
	hexpn = expn;
	hbias = bias;
	
	stage4();
}

/*
 * addOne - Increments the simulated float
 * Behavior: Toggles the checkboxes of the floating point value as if it was an unsigned
 *    integer being incremented
 */
function addOne() {
	var wid = getWid();
	if(wid == -1) return;
	
	var mts = getMantissa(wid);
	if(mts == -1) return;
	var expn = wid - mts - 1;
	
	for(let i = mts - 1; i >= 0; i--) {
		var chk = document.getElementById("mtsbit" + i);
		if(chk.checked) {
			chk.checked = false;
		} else {
			chk.checked = true;
			stage4();
			return;
		}
	}
	
	for(let i = expn - 1; i >= 0; i--) {
		var chk = document.getElementById("expbit" + i);
		if(chk.checked) {
			chk.checked = false;
		} else {
			chk.checked = true;
			stage4();
			return;
		}
	}
	var chk = document.getElementById("sgnbit");
	chk.checked = !chk.checked;
	stage4();
}

/*
 * subOne - Decrements the simulated float
 * Behavior: Toggles the checkboxes of the floating point value as if it was an unsigned
 *    integer being decremented
 */
function subOne() {
	var wid = getWid();
	if(wid == -1) return;
	
	var mts = getMantissa(wid);
	if(mts == -1) return;
	var expn = wid - mts - 1;
	
	for(let i = mts - 1; i >= 0; i--) {
		var chk = document.getElementById("mtsbit" + i);
		if(chk.checked) {
			chk.checked = false;
			stage4();
			return;
		} else {
			chk.checked = true;
		}
	}
	
	for(let i = expn - 1; i >= 0; i--) {
		var chk = document.getElementById("expbit" + i);
		if(chk.checked) {
			chk.checked = false;
			stage4();
			return;
		} else {
			chk.checked = true;
		}
	}
	var chk = document.getElementById("sgnbit");
	chk.checked = !chk.checked;
	stage4();
}

/*
 * setExp - Sets or clears all exponent checkboxes
 * Parameters: True to set the checkboxes, false to clear
 * Behavior: Toggles the checkboxes of the floating point value, setting or clearing all
 *    the exponent checkboxes
 */
function setExp(chk) {
	var wid = getWid();
	if(wid == -1) return;
	
	var mts = getMantissa(wid);
	if(mts == -1) return;
	var expn = wid - mts - 1;
	
	for(let i = 0; i < expn; i++) {
		document.getElementById("expbit" + i).checked = chk;
	}
	stage4();
}

/*
 * setMts - Sets or clears all mantissa checkboxes
 * Parameters: True to set the checkboxes, false to clear
 * Behavior: Toggles the checkboxes of the floating point value, setting or clearing all
 *    the mantissa checkboxes
 */
function setMts(chk) {
	var wid = getWid();
	if(wid == -1) return;
	
	var mts = getMantissa(wid);
	if(mts == -1) return;
	
	for(let i = 0; i < mts; i++) {
		document.getElementById("mtsbit" + i).checked = chk;
	}
	stage4();
}

/*
 * (Depricated)
 */
function toExpn(num) {
	var expn = 0;
	if(num.charAt(0) == "0") {
		expn--;
		for(let i = 2; i < num.length; i++) {
			if(num.charAt(i) == "0") {
				expn--;
			} else break;
		}
		num = num.charAt(-expn + 1) + "." + num.substring(-expn + 2, Math.min(num.length, -expn + 20));
	} else if(num.charAt(1) == ".") {
		return num.substring(0, 22);
	} else {
		var pos = num.indexOf(".");
		if(pos == -1) pos = num.length;
		expn = pos - 1;
		if(pos > 21) {
			num = num.charAt(0) + "." + num.substring(1, 21);
		} else {
			num = num.charAt(0) + "." + num.substring(1, pos) + num.substring(pos + 1, 22);
		}
	}
	num += " x 10 ^ " + expn;
	return num;
}

/*
 * toExpnDiv - Converts raw data to readable output
 * Parameters: A number and an inverse decimal offset, such that a*10^-b gives the real
 *    value
 * Output: The value as a string, processed to be human readable, including exponents
 */
function toExpnDiv(num, dexp) {
	console.log(1);
	// Apply the exponent
	var pwr = -dexp + num.length - 1;
	if(Math.abs(dexp) < 25 || Math.abs(pwr) < 25) {
		if(dexp <= num.length) {
			if(dexp == num.length) {
				num = "0" + num;
			}
			num = num.substring(0, num.length - dexp) + "." + num.substring(num.length - dexp);
		} else {
			var left = dexp - num.length;
			for(let i = 0; i < left; i++) {
				num = "0" + num;
			}
			num = "0." + num;
		}
		dexp = 0;
	}
	
	if(dexp != 0 || num.length > 30) {
		var expn = 0;
		if(num.charAt(0) == "0") {
			expn--;
			for(let i = 2; i < num.length; i++) {
				if(num.charAt(i) == "0") {
					expn--;
				} else break;
			}
			num = num.charAt(-expn + 1) + "." + num.substring(-expn + 2, Math.min(num.length, -expn + 20));
		} else if(num.charAt(1) == ".") {
			return trimZeros(num.substring(0, 22));
		} else {
			var pos = num.indexOf(".");
			if(pos == -1) pos = num.length;
			expn = pos - 1;
			if(pos > 21) {
				num = num.charAt(0) + "." + num.substring(1, 21);
			} else {
				num = num.charAt(0) + "." + num.substring(1, pos) + num.substring(pos + 1, 22);
			}
		}
		expn -= dexp;
		num = trimZeros(num);
		
	//	if(expn != 0) num += " &#x00D7 10 ^ " + expn;
    num *= (10 ** expn);
	} else {
		num = trimZeros(num);
	}
	return num;
}

/*
 * trimZeros - Removes trailing zeros
 * Parameters: A string representation of a number
 * Output: The string with any trailing zeros, and possibly the decimal point, removed
 */
function trimZeros(num) {
	// Trim trailing zeros
	if(num.indexOf(".") != -1) {
		var cut = num.length - 1;
		var atcut = num.charAt(cut);
		while(atcut == "0" || atcut == ".") {
			cut--;
			if(atcut == ".") break;
			atcut = num.charAt(cut);
		}
		num = num.substring(0, cut + 1);
	}
	return num;
}

/*
 * stage4 - Calculates the simulated float's value
 * Behavior: Modifies the HTML layout, adding a stats display and checkboxes for
 */
function stage4() {
	var div = stageClr(4);
	
	var wid = getWid();
	if(wid == -1) return;
	
	var mts = getMantissa(wid);
	if(mts == -1) return;
	var expn = wid - mts - 1;
	
	var bias = getBias();
	if(bias == "") return;
	
	if((hwid != wid) || (hexpn != expn) || (hbias != bias)) {
		stage3();
		return;
	}
	
	var expval = 0n;
	for(let i = 0; i < expn; i++) {
		expval *= 2n;
		if(document.getElementById("expbit" + i).checked) {
			expval += 1n;
		}
	}
	
	// Special case: The exponent is completely set
	var spcase = (expval == (2n ** BigInt(expn) - 1n));
	
	// Subnormal case: The exponent is completely unset
	var sncase = (expval == 0n);
	
	var ntxt = document.createElement("p");
	ntxt.innerHTML = "Raw exponent value: " + expval;
	div.append(ntxt);
	
	var bval;
	if(bias == NOVAL) {
		bval = ((2n ** BigInt(expn - 1)) - 1n);
	} else {
		bval = BigInt(bias);
	}
	expval -= bval;
	ntxt = document.createElement("p");
	ntxt.innerHTML = "Biased exponent value: " + expval;
	div.append(ntxt);
	
	var empty = true;
	var mtsval = sncase ? 0n: 1n;
	for(let i = 0; i < mts; i++) {
		mtsval *= 2n;
		if(document.getElementById("mtsbit" + i).checked) {
			mtsval += 1n;
			empty = false;
		}
	}
	
	var minus = document.getElementById("sgnbit").checked;
	
	var mtsdisp = Number(mtsval) / 2 ** mts;
  if(!spcase) {
  	ntxt = document.createElement("p");
  	ntxt.innerHTML = "Calculation: " + (minus ? "<span class=sgnstyle>-</span> " : "") + "<span class=mtsstyle>" + mtsdisp + "</span> &#x00D7 2 ^ <span class=expstyle>" + (sncase ? expval + 1n : expval) + "</span>";
  	div.append(ntxt);
  }
	
	// ----- Value Calculation -----
	//console.log(Number(mtsval) / (2 ** (sncase ? mts - 1 : mts)) * (2 ** Number(expval)));
	var mtdiv = 2n ** BigInt(sncase ? mts - 1 : mts); // the mantissa divisor
	var dexp = MINACC; // The power of 10 that the mantissa is currently multiplied by, to keep sig figs
	// "dexp" is a negative decimal exponent
	
	// Count off the mantissa divisor's length, to shift the mantissa up and ensure no bits are lost
	// There isn't a log function for BigInts, so...
	var mtlen = BigInt(mtdiv);
	while(mtlen > 0) {
		dexp++;
		mtlen /= 10n;
	}
	
	var fval = mtsval * (10n ** BigInt(dexp)); // The final value
	fval /= mtdiv; // At this point, fval is the pre-exponentiated mantissa, times dexp
	
	if(expval < 0) {
		for(let i = 0n; i > expval; i -= 1n) {
			dexp++;
			fval *= 5n;
		}
	} else {
		for(let i = 0n; i < expval; i += 1n) {
			fval *= 2n;
			while(fval.toString().length > 30) {
				fval /= 10n;
				dexp--;
			}
		}
		//fval *= 2n ** expval;
	}
	
	/*
	ntxt = document.createElement("p");
	ntxt.innerHTML = "Final mantissa: " + fval;
	div.append(ntxt);
	
	ntxt = document.createElement("p");
	ntxt.innerHTML = "Final exponent: " + dexp;
	div.append(ntxt);
	*/
	
	//if(fstr.length > 20) fstr = toExpn(fstr);
	var fstr = fval == 0 ? "0" : toExpnDiv(fval.toString(), dexp);
	if(minus) {
		fstr = "-" + fstr;
	}
	
  if(!spcase) {
  	ntxt = document.createElement("p");
  	ntxt.innerHTML = "Calculated value: " + fstr;
  	div.append(ntxt);
  }
	
	if(spcase) {
		ntxt = document.createElement("p");
		if(empty) {
			if(minus) {
				ntxt.innerHTML = "Actual value: -Infinity";
			} else {
				ntxt.innerHTML = "Actual value: Infinity";
			}
		} else {
			ntxt.innerHTML = "Actual value: NaN";
		}
		div.append(ntxt);
	} else div.append(document.createElement("br"));
}
